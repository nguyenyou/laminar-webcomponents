import com.raquo.laminar.api.L.*
import com.raquo.laminar.codecs.StringAsIsCodec
import scala.language.dynamics

class ReactiveAttr[T](
    val attrName: String,
    val default: T,
    val parse: String => T,
    val codec: com.raquo.laminar.codecs.Codec[T, String],
    val reflect: Boolean = false
) {
  def asHtmlAttr: HtmlAttr[T] = htmlAttr(attrName, codec)

  def :=(value: T): Setter[HtmlElement] = asHtmlAttr := value
}

/** A string union attribute that provides type-safe access via Selectable. The
  * refinement type generated by the macro allows only valid union values.
  */
class StringUnionAttr[T <: String](
    attrName: String,
    default: T,
    parse: String => T,
    codec: com.raquo.laminar.codecs.Codec[T, String],
    reflect: Boolean = false,
    val validValues: Set[String]
) extends ReactiveAttr[T](attrName, default, parse, codec, reflect)
    with Selectable {
  def selectDynamic(name: String): Setter[HtmlElement] = {
    this := name.asInstanceOf[T]
  }
}

object StringUnionAttr {

  /** Creates a StringUnionAttr with a refinement type that only allows valid
    * union values. This is a transparent inline macro that returns a refined
    * type like: StringUnionAttr[T] { def primary: Setter[HtmlElement]; def
    * secondary: Setter[HtmlElement]; ... }
    */
  transparent inline def apply[T <: String](
      attrName: String,
      default: T,
      reflect: Boolean = false
  )(using uv: UnionValues[T]): StringUnionAttr[T] = ${
    applyImpl[T]('attrName, 'default, 'reflect, 'uv)
  }

  def applyImpl[T <: String: scala.quoted.Type](
      attrName: scala.quoted.Expr[String],
      default: scala.quoted.Expr[T],
      reflect: scala.quoted.Expr[Boolean],
      uv: scala.quoted.Expr[UnionValues[T]]
  )(using q: scala.quoted.Quotes): scala.quoted.Expr[StringUnionAttr[T]] = {
    import q.reflect.*
    import scala.quoted.{Expr, Type}

    // Extract literal values from union type
    def collectLiterals(tpe: TypeRepr): List[String] = {
      tpe.dealias match {
        case ConstantType(StringConstant(s)) => List(s)
        case OrType(left, right) =>
          collectLiterals(left) ++ collectLiterals(right)
        case other =>
          report.errorAndAbort(
            s"Expected string literal types in union, got: ${other.show}"
          )
      }
    }

    val literals = collectLiterals(TypeRepr.of[T])

    // Create refinement type with a def for each literal value
    val baseType = TypeRepr.of[StringUnionAttr[T]]
    val setterType = TypeRepr.of[Setter[HtmlElement]]

    // Build refinement: StringUnionAttr[T] { val primary: Setter[...]; val secondary: Setter[...]; ... }
    // Using val (not def) so that Selectable doesn't require () to call
    val refinedType = literals.foldLeft(baseType) { (acc, lit) =>
      Refinement(acc, lit, setterType)
    }

    refinedType.asType match {
      case '[t] =>
        '{
          val validValues = $uv.values
          val codec = new StringUnionCodec[T](validValues, $default)
          (new StringUnionAttr[T](
            $attrName,
            $default,
            parse = (s: String) => {
              if (validValues.contains(s)) s.asInstanceOf[T]
              else $default
            },
            codec,
            $reflect,
            validValues
          )).asInstanceOf[t]
        }.asExprOf[StringUnionAttr[T]]
    }
  }
}

/** Type class to extract valid values from a union type */
trait UnionValues[T] {
  def values: Set[String]
}

object UnionValues {
  import scala.compiletime.*
  import scala.quoted.*

  // Note: must be accessible for inline expansion
  class UnionValuesImpl[T](val values: Set[String]) extends UnionValues[T]

  inline given unionValues[T]: UnionValues[T] =
    new UnionValuesImpl[T](extractValues[T])

  inline def extractValues[T]: Set[String] = ${ extractValuesImpl[T] }

  def extractValuesImpl[T: Type](using Quotes): Expr[Set[String]] = {
    import quotes.reflect.*

    def collectLiterals(tpe: TypeRepr): List[String] = {
      tpe.dealias match {
        case ConstantType(StringConstant(s)) => List(s)
        case OrType(left, right) =>
          collectLiterals(left) ++ collectLiterals(right)
        case other =>
          report.errorAndAbort(
            s"Expected string literal types in union, got: ${other.show}"
          )
      }
    }

    val literals = collectLiterals(TypeRepr.of[T])
    Expr(literals.toSet)
  }
}

/** Codec for string union types */
class StringUnionCodec[T](values: Set[String], default: T)
    extends com.raquo.laminar.codecs.Codec[T, String] {
  override def decode(domValue: String): T = domValue.asInstanceOf[T]
  override def encode(scalaValue: T): String = scalaValue.asInstanceOf[String]
}

object ReactiveAttr {
  def string(
      name: String,
      default: String = "",
      reflect: Boolean = false
  ): ReactiveAttr[String] =
    new ReactiveAttr(name, default, identity, StringAsIsCodec, reflect)

  /** Creates a type-safe string union attribute.
    *
    * Usage:
    * ```scala
    * type Variant = "primary" | "secondary" | "outline"
    * val variant = ReactiveAttr.stringUnion[Variant]("variant", "primary")
    * // Now you get type-safe access: variant.primary, variant.secondary, etc.
    * ```
    */
  transparent inline def stringUnion[T <: String](
      name: String,
      default: T,
      reflect: Boolean = false
  )(using uv: UnionValues[T]): StringUnionAttr[T] =
    StringUnionAttr[T](name, default, reflect)

  def int(
      name: String,
      default: Int = 0,
      reflect: Boolean = false
  ): ReactiveAttr[Int] =
    new ReactiveAttr(
      name,
      default,
      s => s.toIntOption.getOrElse(default),
      com.raquo.laminar.codecs.IntAsStringCodec,
      reflect
    )

  def boolean(
      name: String,
      default: Boolean = false,
      reflect: Boolean = false
  ): ReactiveAttr[Boolean] =
    new ReactiveAttr(
      name,
      default,
      _ != null,
      com.raquo.laminar.codecs.BooleanAsTrueFalseStringCodec,
      reflect
    )

  def double(
      name: String,
      default: Double = 0.0,
      reflect: Boolean = false
  ): ReactiveAttr[Double] =
    new ReactiveAttr(
      name,
      default,
      s => s.toDoubleOption.getOrElse(default),
      com.raquo.laminar.codecs.DoubleAsStringCodec,
      reflect
    )
}
